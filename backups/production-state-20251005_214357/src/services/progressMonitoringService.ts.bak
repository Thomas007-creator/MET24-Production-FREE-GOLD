/**
 * Progress Monitoring Service
 * 
 * Real-time loading progress monitoring voor alle Enhanced AI System services
 * Integreert met alle content services en MCP Bridge
 * 
 * @version 1.0.0
 * @author Thomas
 */

import { logger } from '../utils/logger';

export interface ProgressUpdate {
  id: string;
  service: string;
  operation: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'cancelled';
  progress: number; // 0-100
  message: string;
  startTime: Date;
  endTime?: Date;
  estimatedTimeRemaining?: number;
  data?: any;
  error?: string;
}

export interface ServiceProgress {
  service: string;
  operations: ProgressUpdate[];
  overallProgress: number;
  status: 'idle' | 'active' | 'error';
  lastUpdate: Date;
}

export interface ProgressSummary {
  totalOperations: number;
  completedOperations: number;
  failedOperations: number;
  activeOperations: number;
  overallProgress: number;
  services: ServiceProgress[];
  lastUpdate: Date;
}

export interface ProgressFilter {
  service?: string;
  operation?: string;
  status?: string;
  dateRange?: {
    start: Date;
    end: Date;
  };
}

export interface ProgressMetrics {
  averageCompletionTime: number;
  successRate: number;
  throughput: number; // operations per minute
  errorRate: number;
  lastUpdated: Date;
}

export class ProgressMonitoringService {
  private static instance: ProgressMonitoringService;
  private progressUpdates: Map<string, ProgressUpdate> = new Map();
  private serviceProgress: Map<string, ServiceProgress> = new Map();
  private progressListeners: Set<(update: ProgressUpdate) => void> = new Set();
  private summaryListeners: Set<(summary: ProgressSummary) => void> = new Set();
  private metrics: ProgressMetrics = {
    averageCompletionTime: 0,
    successRate: 0,
    throughput: 0,
    errorRate: 0,
    lastUpdated: new Date()
  };

  private constructor() {
    this.startMetricsCalculation();
  }

  public static getInstance(): ProgressMonitoringService {
    if (!ProgressMonitoringService.instance) {
      ProgressMonitoringService.instance = new ProgressMonitoringService();
    }
    return ProgressMonitoringService.instance;
  }

  /**
   * Start progress monitoring voor een operatie
   */
  startProgress(service: string, operation: string, message: string = 'Starting operation...'): string {
    const id = this.generateProgressId();
    const progressUpdate: ProgressUpdate = {
      id,
      service,
      operation,
      status: 'pending',
      progress: 0,
      message,
      startTime: new Date()
    };

    this.progressUpdates.set(id, progressUpdate);
    this.updateServiceProgress(service, progressUpdate);
    this.notifyListeners(progressUpdate);

    logger.info(`ðŸ”„ Progress started: ${service}/${operation} (${id})`);
    return id;
  }

  /**
   * Update progress voor een operatie
   */
  updateProgress(
    id: string, 
    progress: number, 
    message: string, 
    data?: any,
    estimatedTimeRemaining?: number
  ): void {
    const progressUpdate = this.progressUpdates.get(id);
    if (!progressUpdate) {
      logger.warn(`âš ï¸ Progress update failed: ID ${id} not found`);
      return;
    }

    progressUpdate.progress = Math.min(Math.max(progress, 0), 100);
    progressUpdate.message = message;
    progressUpdate.data = data;
    progressUpdate.estimatedTimeRemaining = estimatedTimeRemaining;
    progressUpdate.status = progress === 100 ? 'completed' : 'in_progress';

    if (progress === 100) {
      progressUpdate.endTime = new Date();
    }

    this.progressUpdates.set(id, progressUpdate);
    this.updateServiceProgress(progressUpdate.service, progressUpdate);
    this.notifyListeners(progressUpdate);

    logger.info(`ðŸ“Š Progress updated: ${progressUpdate.service}/${progressUpdate.operation} - ${progress}% (${id})`);
  }

  /**
   * Complete progress voor een operatie
   */
  completeProgress(id: string, message: string = 'Operation completed successfully', data?: any): void {
    const progressUpdate = this.progressUpdates.get(id);
    if (!progressUpdate) {
      logger.warn(`âš ï¸ Progress completion failed: ID ${id} not found`);
      return;
    }

    progressUpdate.status = 'completed';
    progressUpdate.progress = 100;
    progressUpdate.message = message;
    progressUpdate.data = data;
    progressUpdate.endTime = new Date();

    this.progressUpdates.set(id, progressUpdate);
    this.updateServiceProgress(progressUpdate.service, progressUpdate);
    this.notifyListeners(progressUpdate);

    logger.info(`âœ… Progress completed: ${progressUpdate.service}/${progressUpdate.operation} (${id})`);
  }

  /**
   * Fail progress voor een operatie
   */
  failProgress(id: string, error: string, message: string = 'Operation failed'): void {
    const progressUpdate = this.progressUpdates.get(id);
    if (!progressUpdate) {
      logger.warn(`âš ï¸ Progress failure failed: ID ${id} not found`);
      return;
    }

    progressUpdate.status = 'failed';
    progressUpdate.message = message;
    progressUpdate.error = error;
    progressUpdate.endTime = new Date();

    this.progressUpdates.set(id, progressUpdate);
    this.updateServiceProgress(progressUpdate.service, progressUpdate);
    this.notifyListeners(progressUpdate);

    logger.error(`âŒ Progress failed: ${progressUpdate.service}/${progressUpdate.operation} - ${error} (${id})`);
  }

  /**
   * Cancel progress voor een operatie
   */
  cancelProgress(id: string, message: string = 'Operation cancelled'): void {
    const progressUpdate = this.progressUpdates.get(id);
    if (!progressUpdate) {
      logger.warn(`âš ï¸ Progress cancellation failed: ID ${id} not found`);
      return;
    }

    progressUpdate.status = 'cancelled';
    progressUpdate.message = message;
    progressUpdate.endTime = new Date();

    this.progressUpdates.set(id, progressUpdate);
    this.updateServiceProgress(progressUpdate.service, progressUpdate);
    this.notifyListeners(progressUpdate);

    logger.info(`â¹ï¸ Progress cancelled: ${progressUpdate.service}/${progressUpdate.operation} (${id})`);
  }

  /**
   * Krijg progress voor een specifieke operatie
   */
  getProgress(id: string): ProgressUpdate | undefined {
    return this.progressUpdates.get(id);
  }

  /**
   * Krijg alle progress updates met filtering
   */
  getProgressUpdates(filter: ProgressFilter = {}): ProgressUpdate[] {
    let updates = Array.from(this.progressUpdates.values());

    // Apply filters
    if (filter.service) {
      updates = updates.filter(update => update.service === filter.service);
    }

    if (filter.operation) {
      updates = updates.filter(update => update.operation === filter.operation);
    }

    if (filter.status) {
      updates = updates.filter(update => update.status === filter.status);
    }

    if (filter.dateRange) {
      updates = updates.filter(update => 
        update.startTime >= filter.dateRange!.start && 
        update.startTime <= filter.dateRange!.end
      );
    }

    // Sort by start time (newest first)
    return updates.sort((a, b) => b.startTime.getTime() - a.startTime.getTime());
  }

  /**
   * Krijg progress summary
   */
  getProgressSummary(): ProgressSummary {
    const allUpdates = Array.from(this.progressUpdates.values());
    const services = Array.from(this.serviceProgress.values());

    const summary: ProgressSummary = {
      totalOperations: allUpdates.length,
      completedOperations: allUpdates.filter(u => u.status === 'completed').length,
      failedOperations: allUpdates.filter(u => u.status === 'failed').length,
      activeOperations: allUpdates.filter(u => u.status === 'in_progress' || u.status === 'pending').length,
      overallProgress: this.calculateOverallProgress(allUpdates),
      services,
      lastUpdate: new Date()
    };

    return summary;
  }

  /**
   * Krijg progress metrics
   */
  getProgressMetrics(): ProgressMetrics {
    return { ...this.metrics };
  }

  /**
   * Krijg service progress
   */
  getServiceProgress(service: string): ServiceProgress | undefined {
    return this.serviceProgress.get(service);
  }

  /**
   * Subscribe to progress updates
   */
  subscribeToProgressUpdates(callback: (update: ProgressUpdate) => void): () => void {
    this.progressListeners.add(callback);
    
    // Return unsubscribe function
    return () => {
      this.progressListeners.delete(callback);
    };
  }

  /**
   * Subscribe to progress summary updates
   */
  subscribeToProgressSummary(callback: (summary: ProgressSummary) => void): () => void {
    this.summaryListeners.add(callback);
    
    // Return unsubscribe function
    return () => {
      this.summaryListeners.delete(callback);
    };
  }

  /**
   * Clear completed progress updates
   */
  clearCompletedProgress(olderThanHours: number = 24): number {
    const cutoffTime = new Date(Date.now() - olderThanHours * 60 * 60 * 1000);
    let clearedCount = 0;

    for (const [id, update] of this.progressUpdates.entries()) {
      if ((update.status === 'completed' || update.status === 'failed' || update.status === 'cancelled') &&
          update.endTime && update.endTime < cutoffTime) {
        this.progressUpdates.delete(id);
        clearedCount++;
      }
    }

    // Update service progress
    this.updateAllServiceProgress();

    logger.info(`ðŸ—‘ï¸ Cleared ${clearedCount} completed progress updates older than ${olderThanHours} hours`);
    return clearedCount;
  }

  /**
   * Clear all progress updates
   */
  clearAllProgress(): void {
    this.progressUpdates.clear();
    this.serviceProgress.clear();
    logger.info('ðŸ—‘ï¸ All progress updates cleared');
  }

  /**
   * Krijg progress statistics
   */
  getProgressStatistics(): {
    totalOperations: number;
    completedOperations: number;
    failedOperations: number;
    cancelledOperations: number;
    activeOperations: number;
    averageProgress: number;
    averageCompletionTime: number;
    successRate: number;
  } {
    const allUpdates = Array.from(this.progressUpdates.values());
    const completedUpdates = allUpdates.filter(u => u.status === 'completed');
    const failedUpdates = allUpdates.filter(u => u.status === 'failed');
    const cancelledUpdates = allUpdates.filter(u => u.status === 'cancelled');
    const activeUpdates = allUpdates.filter(u => u.status === 'in_progress' || u.status === 'pending');

    const averageProgress = allUpdates.length > 0 
      ? allUpdates.reduce((sum, u) => sum + u.progress, 0) / allUpdates.length 
      : 0;

    const averageCompletionTime = completedUpdates.length > 0
      ? completedUpdates.reduce((sum, u) => {
          const duration = u.endTime ? u.endTime.getTime() - u.startTime.getTime() : 0;
          return sum + duration;
        }, 0) / completedUpdates.length
      : 0;

    const successRate = allUpdates.length > 0 
      ? (completedUpdates.length / allUpdates.length) * 100 
      : 0;

    return {
      totalOperations: allUpdates.length,
      completedOperations: completedUpdates.length,
      failedOperations: failedUpdates.length,
      cancelledOperations: cancelledUpdates.length,
      activeOperations: activeUpdates.length,
      averageProgress,
      averageCompletionTime,
      successRate
    };
  }

  // Private helper methods

  private generateProgressId(): string {
    return `progress_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private updateServiceProgress(service: string, update: ProgressUpdate): void {
    let serviceProgress = this.serviceProgress.get(service);
    
    if (!serviceProgress) {
      serviceProgress = {
        service,
        operations: [],
        overallProgress: 0,
        status: 'idle',
        lastUpdate: new Date()
      };
    }

    // Update or add operation
    const existingIndex = serviceProgress.operations.findIndex(op => op.id === update.id);
    if (existingIndex >= 0) {
      serviceProgress.operations[existingIndex] = update;
    } else {
      serviceProgress.operations.push(update);
    }

    // Calculate overall progress for service
    serviceProgress.overallProgress = this.calculateServiceProgress(serviceProgress.operations);
    
    // Update service status
    const activeOperations = serviceProgress.operations.filter(op => 
      op.status === 'in_progress' || op.status === 'pending'
    );
    const failedOperations = serviceProgress.operations.filter(op => op.status === 'failed');
    
    if (failedOperations.length > 0) {
      serviceProgress.status = 'error';
    } else if (activeOperations.length > 0) {
      serviceProgress.status = 'active';
    } else {
      serviceProgress.status = 'idle';
    }

    serviceProgress.lastUpdate = new Date();
    this.serviceProgress.set(service, serviceProgress);
  }

  private updateAllServiceProgress(): void {
    // Recalculate all service progress
    for (const [service, serviceProgress] of this.serviceProgress.entries()) {
      const operations = Array.from(this.progressUpdates.values())
        .filter(update => update.service === service);
      
      serviceProgress.operations = operations;
      serviceProgress.overallProgress = this.calculateServiceProgress(operations);
      serviceProgress.lastUpdate = new Date();
    }
  }

  private calculateServiceProgress(operations: ProgressUpdate[]): number {
    if (operations.length === 0) return 0;
    
    const totalProgress = operations.reduce((sum, op) => sum + op.progress, 0);
    return totalProgress / operations.length;
  }

  private calculateOverallProgress(allUpdates: ProgressUpdate[]): number {
    if (allUpdates.length === 0) return 0;
    
    const totalProgress = allUpdates.reduce((sum, update) => sum + update.progress, 0);
    return totalProgress / allUpdates.length;
  }

  private notifyListeners(update: ProgressUpdate): void {
    this.progressListeners.forEach(callback => {
      try {
        callback(update);
      } catch (error) {
        logger.error('âŒ Progress listener error:', { error });
      }
    });
  }

  private startMetricsCalculation(): void {
    // Calculate metrics every 30 seconds
    setInterval(() => {
      this.calculateMetrics();
    }, 30000);
  }

  private calculateMetrics(): void {
    const allUpdates = Array.from(this.progressUpdates.values());
    const completedUpdates = allUpdates.filter(u => u.status === 'completed');
    const failedUpdates = allUpdates.filter(u => u.status === 'failed');

    // Average completion time
    const averageCompletionTime = completedUpdates.length > 0
      ? completedUpdates.reduce((sum, u) => {
          const duration = u.endTime ? u.endTime.getTime() - u.startTime.getTime() : 0;
          return sum + duration;
        }, 0) / completedUpdates.length
      : 0;

    // Success rate
    const successRate = allUpdates.length > 0 
      ? (completedUpdates.length / allUpdates.length) * 100 
      : 0;

    // Throughput (operations per minute)
    const now = new Date();
    const oneMinuteAgo = new Date(now.getTime() - 60 * 1000);
    const recentUpdates = allUpdates.filter(u => u.startTime >= oneMinuteAgo);
    const throughput = recentUpdates.length;

    // Error rate
    const errorRate = allUpdates.length > 0 
      ? (failedUpdates.length / allUpdates.length) * 100 
      : 0;

    this.metrics = {
      averageCompletionTime,
      successRate,
      throughput,
      errorRate,
      lastUpdated: new Date()
    };
  }
}

// Export singleton instance
export const progressMonitoringService = ProgressMonitoringService.getInstance();
