import { journalEntriesCollection, chatMessagesCollection } from '../database';
import { Q } from '@nozbe/watermelondb';
import { logger } from '../utils/logger';

// Types voor vector search
export interface VectorSearchResult {
  id: string;
  table: string;
  content: string;
  levensgebied: string;
  similarity: number;
  metadata: any;
  createdAt: Date;
}
export interface VectorSearchFilters {
  levensgebied?: string;
  dateRange?: { start: Date; end: Date };
  minSimilarity?: number;
  maxResults?: number;
  includeMetadata?: boolean;
  table?: string;
  contentTypes?: string[];
}
export class VectorSearchService {
  private static instance: VectorSearchService;
  private embeddingCache: Map<string, number[]> = new Map();

  private constructor() {
    // Initialize vector search service
    this.embeddingCache = new Map();
  }
  static getInstance(): VectorSearchService {
    if (!VectorSearchService.instance) {
      VectorSearchService.instance = new VectorSearchService();
    }    return VectorSearchService.instance;
  }
  // Generate embedding voor text (OpenAI API)
  async generateEmbedding(text: string): Promise<number[]> {
    try {
      const cacheKey = this.generateCacheKey(text);
      
      // Check cache first
      if (this.embeddingCache.has(cacheKey)) {
        return this.embeddingCache.get(cacheKey)!;
      }
      // Call OpenAI API
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.REACT_APP_OPENAI_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: text,
          model: 'text-embedding-3-small'
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.statusText}`);
      }
      const data = await response.json();
      const embedding = data.data[0].embedding;

      // Cache embedding
      this.embeddingCache.set(cacheKey, embedding);
      
      logger.info('Generated embedding:', { textLength: text.length, embeddingLength: embedding.length });
      return embedding;
    } catch (error) {
      logger.error('Failed to generate embedding:', { error, text: text.substring(0, 100) });
      throw error;
    }  }
  // Local vector similarity search in WatermelonDB
  async localVectorSearch(
    query: string,
    filters: VectorSearchFilters = {}  ): Promise<VectorSearchResult[]> {
    try {
      const queryEmbedding = await this.generateEmbedding(query);
      const results: VectorSearchResult[] = [];

      // Search in journal entries
      if (!filters.table || filters.table === 'journal_entries') {
        const journalResults = await this.searchJournalEntries(queryEmbedding, filters);
        results.push(...journalResults);
      }
      // Search in chat messages
      if (!filters.table || filters.table === 'chat_messages') {
        const chatResults = await this.searchChatMessages(queryEmbedding, filters);
        results.push(...chatResults);
      }
      // Search in AI interactions
      if (!filters.table || filters.table === 'ai_interactions') {
        const aiResults = await this.searchAIInteractions(queryEmbedding, filters);
        results.push(...aiResults);
      }
      // Sort by similarity and apply filters
      const sortedResults = results
        .filter(r => r.similarity >= (filters.minSimilarity || 0.7))
        .sort((a, b) => a.similarity - b.similarity)
        .slice(0, filters.maxResults || 20);

      logger.info('Local vector search completed:', { 
        query: query.substring(0, 50), 
        totalResults: results.length, 
        filteredResults: sortedResults.length 
      });

      return sortedResults;
    } catch (error) {
      logger.error('Local vector search failed:', { error });
      throw error;
    }  }
  // Search journal entries
  private async searchJournalEntries(
    queryEmbedding: number[],
    filters: VectorSearchFilters
  ): Promise<VectorSearchResult[]> {
    try {
      let query = journalEntriesCollection.query();
      
      // Apply filters
      if (filters.levensgebied) {
        query = query.extend(Q.where('levensgebied', filters.levensgebied));
      }      
      if (filters.dateRange) {
        query = query.extend(
          Q.and(
            Q.where('created_at', Q.gte(filters.dateRange.start.getTime())),
            Q.where('created_at', Q.lte(filters.dateRange.end.getTime()))
          )
        );
      }
      const entries = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const entry of entries) {
        if ((entry as any).contentEmbedding) {
          const similarity = this.calculateCosineSimilarity(
            queryEmbedding,
            JSON.parse((entry as any).contentEmbedding)
          );

          results.push({
            id: entry.id,
            table: 'journal_entries',
            content: (entry as any).entryText,
            levensgebied: (entry as any).levensgebied,
            similarity,
            metadata: {
              moodRating: (entry as any).moodRating,
              tags: (entry as any).tags ? JSON.parse((entry as any).tags) : []
            },
            createdAt: (entry as any).createdAt
          });
        }      }
      return results;
    } catch (error) {
      logger.error('Journal entries search failed:', { error });
      return [];
    }  }
  // Search chat messages
  private async searchChatMessages(
    queryEmbedding: number[],
    filters: VectorSearchFilters
  ): Promise<VectorSearchResult[]> {
    try {
      let query = chatMessagesCollection.query();
      
      // Apply filters
      if (filters.dateRange) {
        query = query.extend(
          Q.and(
            Q.where('created_at', Q.gte(filters.dateRange.start.getTime())),
            Q.where('created_at', Q.lte(filters.dateRange.end.getTime()))
          )
        );
      }
      const messages = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const message of messages) {
        if ((message as any).messageEmbedding) {
          const similarity = this.calculateCosineSimilarity(
            queryEmbedding,
            JSON.parse((message as any).messageEmbedding)
          );

          results.push({
            id: message.id,
            table: 'chat_messages',
            content: (message as any).messageText,
            levensgebied: (message as any).levensgebied || 'general',
            similarity,
            metadata: {
              messageType: (message as any).messageType,
              aiModelUsed: (message as any).aiModelUsed,
              tokensUsed: (message as any).tokensUsed
            },
            createdAt: (message as any).createdAt
          });
        }      }
      return results;
    } catch (error) {
      logger.error('Chat messages search failed:', { error });
      return [];
    }  }
  // Search AI interactions
  private async searchAIInteractions(
    _queryEmbedding: number[],
    _filters: VectorSearchFilters
  ): Promise<VectorSearchResult[]> {
    try {
      // This would search in AIInteraction table
      // Implementation depends on your AIInteraction model structure
      return [];
    } catch (error) {
      logger.error('AI interactions search failed:', { error });
      return [];
    }  }
  // Calculate cosine similarity between two vectors
  private calculateCosineSimilarity(vecA: number[], vecB: number[]): number {
    if (vecA.length !== vecB.length) {
      throw new Error('Vector dimensions must match');
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);

    if (normA === 0 || normB === 0) {
      return 0;
    }
    return dotProduct / (normA * normB);
  }
  // Generate cache key for text
  private generateCacheKey(text: string): string {
    return btoa(text.substring(0, 100)).replace(/[^a-zA-Z0-9]/g, '');
  }
  // Clear embedding cache
  clearCache(): void {
    this.embeddingCache.clear();
    logger.info('Embedding cache cleared');
  }
  // Get cache statistics
  getCacheStats(): { size: number; hitRate: number } {
    return {
      size: this.embeddingCache.size,
      hitRate: 0.8 // Placeholder - implement actual hit rate tracking
    };
  }
  // Nieuwe methode: Search met uitgebreide content types
  async searchWithExpandedTypes(
    query: string, 
    contentTypes: string[] = ['text', 'image', 'audio', 'video']
  ): Promise<VectorSearchResult[]> {
    try {
      const embedding = await this.generateEmbedding(query);
      
      logger.info('Expanded content type search:', { 
        query: query.substring(0, 50), 
        contentTypes 
      });

      const results: VectorSearchResult[] = [];

      // Search in alle beschikbare tabellen met content type filtering
      const searchPromises = [];

      // Journal entries met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('journal')) {
        searchPromises.push(
          this.searchJournalEntriesWithTypes(embedding, contentTypes)
        );
      }
      // Chat messages met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('chat')) {
        searchPromises.push(
          this.searchChatMessagesWithTypes(embedding, contentTypes)
        );
      }
      // AI interactions met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('ai')) {
        searchPromises.push(
          this.searchAIInteractionsWithTypes(embedding, contentTypes)
        );
      }
      // Content items met media type filtering
      if (contentTypes.some(type => ['image', 'audio', 'video', 'media'].includes(type))) {
        searchPromises.push(
          this.searchContentItemsWithTypes(embedding, contentTypes)
        );
      }
      // Wacht op alle searches
      const searchResults = await Promise.all(searchPromises);
      
      // Combineer alle resultaten
      for (const searchResult of searchResults) {
        results.push(...searchResult);
      }
      // Sorteer op similarity
      const sortedResults = results
        .filter(r => r.similarity >= 0.7)
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, 20);

      logger.info('Expanded content type search completed:', { 
        totalResults: results.length, 
        filteredResults: sortedResults.length,
        contentTypes 
      });

      return sortedResults;

    } catch (error) {
      logger.error('Expanded content type search failed:', { error, contentTypes });
      throw error;
    }  }
  // Search journal entries met content type filtering
  private async searchJournalEntriesWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      let query = journalEntriesCollection.query();
      
      // Filter op content types (als je een content_type veld hebt)
      // Voor nu, behandel alle journal entries als 'text' type
      if (!contentTypes.includes('text') && !contentTypes.includes('journal')) {
        return [];
      }
      const entries = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const entry of entries) {
        if ((entry as any).contentEmbedding) {
          const similarity = this.calculateCosineSimilarity(
            queryEmbedding,
            JSON.parse((entry as any).contentEmbedding)
          );

          results.push({
            id: entry.id,
            table: 'journal_entries',
            content: (entry as any).entryText,
            levensgebied: (entry as any).levensgebied,
            similarity,
            metadata: {
              contentType: 'text',
              moodRating: (entry as any).moodRating,
              tags: (entry as any).tags ? JSON.parse((entry as any).tags) : []
            },
            createdAt: (entry as any).createdAt
          });
        }      }
      return results;
    } catch (error) {
      logger.error('Journal entries with types search failed:', { error });
      return [];
    }  }
  // Search chat messages met content type filtering
  private async searchChatMessagesWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      let query = chatMessagesCollection.query();
      
      // Filter op content types
      if (!contentTypes.includes('text') && !contentTypes.includes('chat')) {
        return [];
      }
      const messages = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const message of messages) {
        if ((message as any).messageEmbedding) {
          const similarity = this.calculateCosineSimilarity(
            queryEmbedding,
            JSON.parse((message as any).messageEmbedding)
          );

          results.push({
            id: message.id,
            table: 'chat_messages',
            content: (message as any).messageText,
            levensgebied: (message as any).levensgebied || 'general',
            similarity,
            metadata: {
              contentType: 'text',
              messageType: (message as any).messageType,
              aiModelUsed: (message as any).aiModelUsed,
              tokensUsed: (message as any).tokensUsed
            },
            createdAt: (message as any).createdAt
          });
        }      }
      return results;
    } catch (error) {
      logger.error('Chat messages with types search failed:', { error });
      return [];
    }  }
  // Search AI interactions met content type filtering
  private async searchAIInteractionsWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      // Filter op content types
      if (!contentTypes.includes('text') && !contentTypes.includes('ai')) {
        return [];
      }
      // Implementatie afhankelijk van je AIInteraction model
      // Voor nu, return lege array
      return [];
    } catch (error) {
      logger.error('AI interactions with types search failed:', { error });
      return [];
    }  }
  // Search content items met media type filtering
  private async searchContentItemsWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      // Import content items collection
      const { contentItemsCollection } = await import('../database');
      
      let query = contentItemsCollection.query();
      
      // Filter op media types
      const mediaTypes = contentTypes.filter(type => 
        ['image', 'audio', 'video', 'media'].includes(type)
      );
      
      if (mediaTypes.length === 0) {
        return [];
      }
      const items = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const item of items) {
        if ((item as any).contentEmbedding) {
          const itemContentType = (item as any).contentType || 'text';
          
          // Check of dit item type overeenkomt met gevraagde types
          if (mediaTypes.includes(itemContentType) || 
              (itemContentType === 'media' && mediaTypes.length > 0)) {
            
            const similarity = this.calculateCosineSimilarity(
              queryEmbedding,
              JSON.parse((item as any).contentEmbedding)
            );

            results.push({
              id: item.id,
              table: 'content_items',
              content: (item as any).title || (item as any).content,
              levensgebied: (item as any).levensgebied || 'general',
              similarity,
              metadata: {
                contentType: itemContentType,
                mediaUrl: (item as any).mediaUrl,
                fileSize: (item as any).fileSize,
                duration: (item as any).duration
              },
              createdAt: (item as any).createdAt
            });
          }        }      }
      return results;
    } catch (error) {
      logger.error('Content items with types search failed:', { error });
      return [];
    }
  }
}

    query: string, 
    contentTypes: string[] = ['text', 'image', 'audio', 'video']
  ): Promise<VectorSearchResult[]> {
    try {
      const embedding = await this.generateEmbedding(query);
      
      logger.info('Expanded content type search:', { 
        query: query.substring(0, 50), 
        contentTypes 
      });

      const results: VectorSearchResult[] = [];

      // Search in alle beschikbare tabellen met content type filtering
      const searchPromises = [];

      // Journal entries met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('journal')) {
        searchPromises.push(
          this.searchJournalEntriesWithTypes(embedding, contentTypes)
        );
      }
      // Chat messages met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('chat')) {
        searchPromises.push(
          this.searchChatMessagesWithTypes(embedding, contentTypes)
        );
      }
      // AI interactions met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('ai')) {
        searchPromises.push(
          this.searchAIInteractionsWithTypes(embedding, contentTypes)
        );
      }
      // Content items met media type filtering
      if (contentTypes.some(type => ['image', 'audio', 'video', 'media'].includes(type))) {
        searchPromises.push(
          this.searchContentItemsWithTypes(embedding, contentTypes)
        );
      }
      // Wacht op alle searches
      const searchResults = await Promise.all(searchPromises);
      
      // Combineer alle resultaten
      for (const searchResult of searchResults) {
        results.push(...searchResult);
      }
      // Sorteer op similarity
      const sortedResults = results
        .filter(r => r.similarity >= 0.7)
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, 20);

      logger.info('Expanded content type search completed:', { 
        totalResults: results.length, 
        filteredResults: sortedResults.length,
        contentTypes 
      });

      return sortedResults;

    } catch (error) {
      logger.error('Expanded content type search failed:', { error, contentTypes });
      throw error;
    }  }
  // Search journal entries met content type filtering
  private async searchJournalEntriesWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      let query = journalEntriesCollection.query();
      
      // Filter op content types (als je een content_type veld hebt)
      // Voor nu, behandel alle journal entries als 'text' type
      if (!contentTypes.includes('text') && !contentTypes.includes('journal')) {
        return [];
      }
      const entries = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const entry of entries) {
        if ((entry as any).contentEmbedding) {
          const similarity = this.calculateCosineSimilarity(
            queryEmbedding,
            JSON.parse((entry as any).contentEmbedding)
          );

          results.push({
            id: entry.id,
            table: 'journal_entries',
            content: (entry as any).entryText,
            levensgebied: (entry as any).levensgebied,
            similarity,
            metadata: {
              contentType: 'text',
              moodRating: (entry as any).moodRating,
              tags: (entry as any).tags ? JSON.parse((entry as any).tags) : []
            },
            createdAt: (entry as any).createdAt
          });
        }      }
      return results;
    } catch (error) {
      logger.error('Journal entries with types search failed:', { error });
      return [];
    }  }
  // Search chat messages met content type filtering
  private async searchChatMessagesWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      let query = chatMessagesCollection.query();
      
      // Filter op content types
      if (!contentTypes.includes('text') && !contentTypes.includes('chat')) {
        return [];
      }
      const messages = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const message of messages) {
        if ((message as any).messageEmbedding) {
          const similarity = this.calculateCosineSimilarity(
            queryEmbedding,
            JSON.parse((message as any).messageEmbedding)
          );

          results.push({
            id: message.id,
            table: 'chat_messages',
            content: (message as any).messageText,
            levensgebied: (message as any).levensgebied || 'general',
            similarity,
            metadata: {
              contentType: 'text',
              messageType: (message as any).messageType,
              aiModelUsed: (message as any).aiModelUsed,
              tokensUsed: (message as any).tokensUsed
            },
            createdAt: (message as any).createdAt
          });
        }      }
      return results;
    } catch (error) {
      logger.error('Chat messages with types search failed:', { error });
      return [];
    }  }
  // Search AI interactions met content type filtering
  private async searchAIInteractionsWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      // Filter op content types
      if (!contentTypes.includes('text') && !contentTypes.includes('ai')) {
        return [];
      }
      // Implementatie afhankelijk van je AIInteraction model
      // Voor nu, return lege array
      return [];
    } catch (error) {
      logger.error('AI interactions with types search failed:', { error });
      return [];
    }  }
  // Search content items met media type filtering
  private async searchContentItemsWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      // Import content items collection
      const { contentItemsCollection } = await import('../database');
      
      let query = contentItemsCollection.query();
      
      // Filter op media types
      const mediaTypes = contentTypes.filter(type => 
        ['image', 'audio', 'video', 'media'].includes(type)
      );
      
      if (mediaTypes.length === 0) {
        return [];
      }
      const items = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const item of items) {
        if ((item as any).contentEmbedding) {
          const itemContentType = (item as any).contentType || 'text';
          
          // Check of dit item type overeenkomt met gevraagde types
          if (mediaTypes.includes(itemContentType) || 
              (itemContentType === 'media' && mediaTypes.length > 0)) {
            
            const similarity = this.calculateCosineSimilarity(
              queryEmbedding,
              JSON.parse((item as any).contentEmbedding)
            );

            results.push({
              id: item.id,
              table: 'content_items',
              content: (item as any).title || (item as any).content,
              levensgebied: (item as any).levensgebied || 'general',
              similarity,
              metadata: {
                contentType: itemContentType,
                mediaUrl: (item as any).mediaUrl,
                fileSize: (item as any).fileSize,
                duration: (item as any).duration
              },
              createdAt: (item as any).createdAt
            });
          }        }      }
      return results;
    } catch (error) {
      logger.error('Content items with types search failed:', { error });
      return [];
    }
  }
}

    query: string, 
    contentTypes: string[] = ['text', 'image', 'audio', 'video']
  ): Promise<VectorSearchResult[]> {
    try {
      const embedding = await this.generateEmbedding(query);
      
      logger.info('Expanded content type search:', { 
        query: query.substring(0, 50), 
        contentTypes 
      });

      const results: VectorSearchResult[] = [];

      // Search in alle beschikbare tabellen met content type filtering
      const searchPromises = [];

      // Journal entries met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('journal')) {
        searchPromises.push(
          this.searchJournalEntriesWithTypes(embedding, contentTypes)
        );
      }
      // Chat messages met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('chat')) {
        searchPromises.push(
          this.searchChatMessagesWithTypes(embedding, contentTypes)
        );
      }
      // AI interactions met content type filtering
      if (contentTypes.includes('text') || contentTypes.includes('ai')) {
        searchPromises.push(
          this.searchAIInteractionsWithTypes(embedding, contentTypes)
        );
      }
      // Content items met media type filtering
      if (contentTypes.some(type => ['image', 'audio', 'video', 'media'].includes(type))) {
        searchPromises.push(
          this.searchContentItemsWithTypes(embedding, contentTypes)
        );
      }
      // Wacht op alle searches
      const searchResults = await Promise.all(searchPromises);
      
      // Combineer alle resultaten
      for (const searchResult of searchResults) {
        results.push(...searchResult);
      }
      // Sorteer op similarity
      const sortedResults = results
        .filter(r => r.similarity >= 0.7)
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, 20);

      logger.info('Expanded content type search completed:', { 
        totalResults: results.length, 
        filteredResults: sortedResults.length,
        contentTypes 
      });

      return sortedResults;

    } catch (error) {
      logger.error('Expanded content type search failed:', { error, contentTypes });
      throw error;
    }  }
  // Search journal entries met content type filtering
  private async searchJournalEntriesWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      let query = journalEntriesCollection.query();
      
      // Filter op content types (als je een content_type veld hebt)
      // Voor nu, behandel alle journal entries als 'text' type
      if (!contentTypes.includes('text') && !contentTypes.includes('journal')) {
        return [];
      }
      const entries = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const entry of entries) {
        if ((entry as any).contentEmbedding) {
          const similarity = this.calculateCosineSimilarity(
            queryEmbedding,
            JSON.parse((entry as any).contentEmbedding)
          );

          results.push({
            id: entry.id,
            table: 'journal_entries',
            content: (entry as any).entryText,
            levensgebied: (entry as any).levensgebied,
            similarity,
            metadata: {
              contentType: 'text',
              moodRating: (entry as any).moodRating,
              tags: (entry as any).tags ? JSON.parse((entry as any).tags) : []
            },
            createdAt: (entry as any).createdAt
          });
        }      }
      return results;
    } catch (error) {
      logger.error('Journal entries with types search failed:', { error });
      return [];
    }  }
  // Search chat messages met content type filtering
  private async searchChatMessagesWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      let query = chatMessagesCollection.query();
      
      // Filter op content types
      if (!contentTypes.includes('text') && !contentTypes.includes('chat')) {
        return [];
      }
      const messages = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const message of messages) {
        if ((message as any).messageEmbedding) {
          const similarity = this.calculateCosineSimilarity(
            queryEmbedding,
            JSON.parse((message as any).messageEmbedding)
          );

          results.push({
            id: message.id,
            table: 'chat_messages',
            content: (message as any).messageText,
            levensgebied: (message as any).levensgebied || 'general',
            similarity,
            metadata: {
              contentType: 'text',
              messageType: (message as any).messageType,
              aiModelUsed: (message as any).aiModelUsed,
              tokensUsed: (message as any).tokensUsed
            },
            createdAt: (message as any).createdAt
          });
        }      }
      return results;
    } catch (error) {
      logger.error('Chat messages with types search failed:', { error });
      return [];
    }  }
  // Search AI interactions met content type filtering
  private async searchAIInteractionsWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      // Filter op content types
      if (!contentTypes.includes('text') && !contentTypes.includes('ai')) {
        return [];
      }
      // Implementatie afhankelijk van je AIInteraction model
      // Voor nu, return lege array
      return [];
    } catch (error) {
      logger.error('AI interactions with types search failed:', { error });
      return [];
    }  }
  // Search content items met media type filtering
  private async searchContentItemsWithTypes(
    queryEmbedding: number[],
    contentTypes: string[]
  ): Promise<VectorSearchResult[]> {
    try {
      // Import content items collection
      const { contentItemsCollection } = await import('../database');
      
      let query = contentItemsCollection.query();
      
      // Filter op media types
      const mediaTypes = contentTypes.filter(type => 
        ['image', 'audio', 'video', 'media'].includes(type)
      );
      
      if (mediaTypes.length === 0) {
        return [];
      }
      const items = await query.fetch();
      const results: VectorSearchResult[] = [];

      for (const item of items) {
        if ((item as any).contentEmbedding) {
          const itemContentType = (item as any).contentType || 'text';
          
          // Check of dit item type overeenkomt met gevraagde types
          if (mediaTypes.includes(itemContentType) || 
              (itemContentType === 'media' && mediaTypes.length > 0)) {
            
            const similarity = this.calculateCosineSimilarity(
              queryEmbedding,
              JSON.parse((item as any).contentEmbedding)
            );

            results.push({
              id: item.id,
              table: 'content_items',
              content: (item as any).title || (item as any).content,
              levensgebied: (item as any).levensgebied || 'general',
              similarity,
              metadata: {
                contentType: itemContentType,
                mediaUrl: (item as any).mediaUrl,
                fileSize: (item as any).fileSize,
                duration: (item as any).duration
              },
              createdAt: (item as any).createdAt
            });
          }        }      }
      return results;
    } catch (error) {
      logger.error('Content items with types search failed:', { error });
      return [];
    }
  }
}
