/**
 * MCP Bridge Integration Service
 * 
 * Verbeterde service communicatie tussen Development app en Mini-MCP Orchestrator
 * Integreert met Enhanced AI System en alle content services
 * 
 * @version 1.0.0
 * @author Thomas
 */

import { logger } from '../utils/logger';

export interface MCPBridgeConfig {
  orchestratorUrl: string;
  contentLoaderUrl: string;
  timeout: number;
  retryAttempts: number;
  retryDelay: number;
}

export interface MCPRequest {
  service: string;
  action: string;
  data: any;
  requestId: string;
  timestamp: Date;
}

export interface MCPResponse {
  success: boolean;
  data?: any;
  error?: string;
  requestId: string;
  timestamp: Date;
  processingTime: number;
}

export interface MCPServiceStatus {
  service: string;
  status: 'online' | 'offline' | 'error';
  lastCheck: Date;
  responseTime: number;
  error?: string;
}

export interface MCPHealthCheck {
  overall: 'healthy' | 'degraded' | 'unhealthy';
  services: MCPServiceStatus[];
  lastCheck: Date;
  uptime: number;
}

export interface MCPContentRequest {
  contentType: string;
  mbtiType?: string;
  filter?: any;
  options?: {
    limit?: number;
    offset?: number;
    qualityThreshold?: number;
  };
}

export interface MCPAIGenerationRequest {
  mbtiType: string;
  contentType: string;
  prompt: string;
  context?: any;
  qualityThreshold?: number;
}

export class MCPBridgeIntegrationService {
  private static instance: MCPBridgeIntegrationService;
  private config: MCPBridgeConfig;
  private serviceStatuses: Map<string, MCPServiceStatus> = new Map();
  private requestQueue: MCPRequest[] = [];
  private isProcessing = false;
  private startTime: Date = new Date();

  private constructor() {
    this.config = {
      orchestratorUrl: process.env.REACT_APP_MCP_ORCHESTRATOR_URL || 'http://localhost:3001',
      contentLoaderUrl: process.env.REACT_APP_CONTENT_LOADER_URL || 'http://localhost:3006',
      timeout: 30000, // 30 seconds
      retryAttempts: 3,
      retryDelay: 1000 // 1 second
    };
  }

  public static getInstance(): MCPBridgeIntegrationService {
    if (!MCPBridgeIntegrationService.instance) {
      MCPBridgeIntegrationService.instance = new MCPBridgeIntegrationService();
    }
    return MCPBridgeIntegrationService.instance;
  }

  /**
   * Initialiseer MCP Bridge
   */
  async initialize(): Promise<void> {
    try {
      logger.info('üöÄ Initializing MCP Bridge Integration Service...');

      // Check service health
      await this.checkServiceHealth();

      // Start periodic health checks
      this.startHealthChecks();

      logger.info('‚úÖ MCP Bridge Integration Service initialized');

    } catch (error) {
      logger.error('‚ùå Failed to initialize MCP Bridge:', { error });
      throw error;
    }
  }

  /**
   * Verstuur request naar MCP service
   */
  async sendRequest(request: MCPRequest): Promise<MCPResponse> {
    try {
      logger.info(`üîÑ Sending MCP request: ${request.service}/${request.action}`);

      const startTime = Date.now();
      const response = await this.executeRequest(request);
      const processingTime = Date.now() - startTime;

      const mcpResponse: MCPResponse = {
        success: response.success,
        data: response.data,
        error: response.error,
        requestId: request.requestId,
        timestamp: new Date(),
        processingTime
      };

      logger.info(`‚úÖ MCP request completed: ${request.service}/${request.action} (${processingTime}ms)`);
      return mcpResponse;

    } catch (error) {
      logger.error(`‚ùå MCP request failed: ${request.service}/${request.action}`, { error });
      
      return {
        success: false,
        error: error.message,
        requestId: request.requestId,
        timestamp: new Date(),
        processingTime: 0
      };
    }
  }

  /**
   * Laad content via MCP Bridge
   */
  async loadContent(request: MCPContentRequest): Promise<any> {
    try {
      logger.info('üîÑ Loading content via MCP Bridge:', request);

      const mcpRequest: MCPRequest = {
        service: 'content_loader',
        action: 'load_content',
        data: request,
        requestId: this.generateRequestId(),
        timestamp: new Date()
      };

      const response = await this.sendRequest(mcpRequest);

      if (!response.success) {
        throw new Error(`Content loading failed: ${response.error}`);
      }

      logger.info(`‚úÖ Content loaded via MCP Bridge: ${response.data?.count || 0} items`);
      return response.data;

    } catch (error) {
      logger.error('‚ùå Failed to load content via MCP Bridge:', { error });
      throw error;
    }
  }

  /**
   * Genereer AI content via MCP Bridge
   */
  async generateAIContent(request: MCPAIGenerationRequest): Promise<any> {
    try {
      logger.info('üîÑ Generating AI content via MCP Bridge:', request);

      const mcpRequest: MCPRequest = {
        service: 'orchestrator',
        action: 'generate_ai_content',
        data: request,
        requestId: this.generateRequestId(),
        timestamp: new Date()
      };

      const response = await this.sendRequest(mcpRequest);

      if (!response.success) {
        throw new Error(`AI content generation failed: ${response.error}`);
      }

      logger.info(`‚úÖ AI content generated via MCP Bridge: ${response.data?.id || 'unknown'}`);
      return response.data;

    } catch (error) {
      logger.error('‚ùå Failed to generate AI content via MCP Bridge:', { error });
      throw error;
    }
  }

  /**
   * Krijg service health status
   */
  async getServiceHealth(): Promise<MCPHealthCheck> {
    try {
      logger.info('üîÑ Checking MCP service health...');

      const services: MCPServiceStatus[] = [];
      let overallStatus: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';

      // Check orchestrator service
      const orchestratorStatus = await this.checkServiceStatus('orchestrator', this.config.orchestratorUrl);
      services.push(orchestratorStatus);

      // Check content loader service
      const contentLoaderStatus = await this.checkServiceStatus('content_loader', this.config.contentLoaderUrl);
      services.push(contentLoaderStatus);

      // Determine overall status
      const offlineServices = services.filter(s => s.status === 'offline').length;
      const errorServices = services.filter(s => s.status === 'error').length;

      if (offlineServices > 0 || errorServices > 0) {
        overallStatus = errorServices > 0 ? 'unhealthy' : 'degraded';
      }

      const healthCheck: MCPHealthCheck = {
        overall: overallStatus,
        services,
        lastCheck: new Date(),
        uptime: Date.now() - this.startTime.getTime()
      };

      logger.info(`‚úÖ MCP service health check completed: ${overallStatus}`);
      return healthCheck;

    } catch (error) {
      logger.error('‚ùå Failed to check service health:', { error });
      throw error;
    }
  }

  /**
   * Krijg service status
   */
  getServiceStatus(service: string): MCPServiceStatus | undefined {
    return this.serviceStatuses.get(service);
  }

  /**
   * Update service configuratie
   */
  updateConfig(newConfig: Partial<MCPBridgeConfig>): void {
    this.config = { ...this.config, ...newConfig };
    logger.info('üîß MCP Bridge configuration updated:', this.config);
  }

  /**
   * Verstuur batch requests
   */
  async sendBatchRequests(requests: MCPRequest[]): Promise<MCPResponse[]> {
    try {
      logger.info(`üîÑ Sending batch of ${requests.length} MCP requests`);

      const responses: MCPResponse[] = [];

      // Process requests in parallel with concurrency limit
      const concurrencyLimit = 5;
      const chunks = this.chunkArray(requests, concurrencyLimit);

      for (const chunk of chunks) {
        const chunkPromises = chunk.map(request => this.sendRequest(request));
        const chunkResponses = await Promise.all(chunkPromises);
        responses.push(...chunkResponses);
      }

      logger.info(`‚úÖ Batch requests completed: ${responses.length} responses`);
      return responses;

    } catch (error) {
      logger.error('‚ùå Failed to send batch requests:', { error });
      throw error;
    }
  }

  /**
   * Krijg request queue status
   */
  getQueueStatus(): { pending: number; processing: boolean } {
    return {
      pending: this.requestQueue.length,
      processing: this.isProcessing
    };
  }

  /**
   * Clear request queue
   */
  clearQueue(): void {
    this.requestQueue = [];
    logger.info('üóëÔ∏è MCP request queue cleared');
  }

  // Private helper methods

  private async executeRequest(request: MCPRequest): Promise<any> {
    const url = this.getServiceUrl(request.service);
    if (!url) {
      throw new Error(`Unknown service: ${request.service}`);
    }

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

    try {
      const response = await fetch(`${url}/api/${request.action}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Request-ID': request.requestId,
          'X-Timestamp': request.timestamp.toISOString()
        },
        body: JSON.stringify(request.data),
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      return { success: true, data };

    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error.name === 'AbortError') {
        throw new Error('Request timeout');
      }
      
      throw error;
    }
  }

  private getServiceUrl(service: string): string | null {
    switch (service) {
      case 'orchestrator':
        return this.config.orchestratorUrl;
      case 'content_loader':
        return this.config.contentLoaderUrl;
      default:
        return null;
    }
  }

  private async checkServiceHealth(): Promise<void> {
    try {
      // Check orchestrator
      await this.checkServiceStatus('orchestrator', this.config.orchestratorUrl);
      
      // Check content loader
      await this.checkServiceStatus('content_loader', this.config.contentLoaderUrl);

    } catch (error) {
      logger.warn('‚ö†Ô∏è Service health check failed:', error);
    }
  }

  private async checkServiceStatus(service: string, url: string): Promise<MCPServiceStatus> {
    try {
      const startTime = Date.now();
      
      const response = await fetch(`${url}/health`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });

      const responseTime = Date.now() - startTime;
      const status: MCPServiceStatus = {
        service,
        status: response.ok ? 'online' : 'error',
        lastCheck: new Date(),
        responseTime,
        error: response.ok ? undefined : `HTTP ${response.status}`
      };

      this.serviceStatuses.set(service, status);
      return status;

    } catch (error) {
      const status: MCPServiceStatus = {
        service,
        status: 'offline',
        lastCheck: new Date(),
        responseTime: 0,
        error: error.message
      };

      this.serviceStatuses.set(service, status);
      return status;
    }
  }

  private startHealthChecks(): void {
    // Check health every 30 seconds
    setInterval(async () => {
      try {
        await this.checkServiceHealth();
      } catch (error) {
        logger.warn('‚ö†Ô∏è Periodic health check failed:', error);
      }
    }, 30000);
  }

  private generateRequestId(): string {
    return `mcp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}

// Export singleton instance
export const mcpBridgeIntegrationService = MCPBridgeIntegrationService.getInstance();
