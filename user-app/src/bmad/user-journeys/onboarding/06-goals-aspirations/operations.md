# Onboarding Step 6: Goals/Aspirations - Operations

## Atomic Operations

### Core Goal Collection Operations

#### 1. Aspirational Goal Capture Operation
```typescript
interface AspirationalGoalCaptureOperation {
  // Input: User's aspirational input
  input: {
    aspirationalInput: string;
    userContext: UserContext;
    personalityProfile: MBTIProfile;
    demographicContext: DemographicContext;
  };
  
  // Atomic steps
  steps: [
    'parse_aspirational_language',
    'extract_core_values_and_themes',
    'identify_personality_motivation_patterns',
    'assess_aspiration_meaningfulness',
    'generate_clarification_questions'
  ];
  
  // Expected outcome
  result: {
    structuredAspirations: AspirationalFramework;
    personalityAlignmentScore: number;
    clarificationNeeded: ClarificationQuestion[];
    meaningfulnessAssessment: MeaningfulnessScore;
  };
  
  // Error scenarios
  errors: [
    'vague_aspirational_input',
    'conflicting_aspirational_values',
    'personality_misalignment',
    'meaningfulness_assessment_failure'
  ];
}

// Implementation
async function executeAspirationalGoalCapture(
  aspirationalInput: string,
  userContext: UserContext,
  personalityProfile: MBTIProfile
): Promise<AspirationalGoalCaptureResult> {
  try {
    // 1. Parse aspirational language using NLP
    const parsedAspirations = await parseAspirationalLanguage({
      input: aspirationalInput,
      context: userContext,
      personalityContext: personalityProfile
    });
    
    if (!parsedAspirations.isValid) {
      return {
        success: false,
        error: 'vague_aspirational_input',
        clarificationQuestions: generateBasicClarificationQuestions(personalityProfile)
      };
    }
    
    // 2. Extract core values and themes
    const valueExtractionResult = await extractCoreValuesAndThemes({
      parsedAspirations,
      personalityProfile,
      demographicContext: userContext.demographicContext
    });
    
    // 3. Identify personality motivation patterns
    const motivationPatterns = identifyPersonalityMotivationPatterns({
      aspirations: parsedAspirations,
      personality: personalityProfile,
      extractedValues: valueExtractionResult.coreValues
    });
    
    // 4. Assess aspiration meaningfulness
    const meaningfulnessAssessment = await assessAspirationMeaningfulness({
      aspirations: parsedAspirations,
      values: valueExtractionResult.coreValues,
      motivationPatterns,
      personalityProfile
    });
    
    // 5. Generate personality-informed clarification questions
    const clarificationQuestions = generatePersonalityInformedClarificationQuestions({
      aspirations: parsedAspirations,
      personalityProfile,
      meaningfulness: meaningfulnessAssessment,
      identifiedGaps: valueExtractionResult.gaps
    });
    
    // Track aspirational capture success
    trackEvent('aspirational_goal_captured', {\n      personalityType: personalityProfile.type,\n      aspirationThemes: valueExtractionResult.themes,\n      meaningfulnessScore: meaningfulnessAssessment.score,\n      clarificationNeeded: clarificationQuestions.length\n    });\n    \n    return {\n      success: true,\n      structuredAspirations: {\n        parsedAspirations,\n        coreValues: valueExtractionResult.coreValues,\n        themes: valueExtractionResult.themes,\n        motivationPatterns\n      },\n      personalityAlignmentScore: calculatePersonalityAlignmentScore({\n        aspirations: parsedAspirations,\n        personality: personalityProfile,\n        motivationPatterns\n      }),\n      clarificationQuestions,\n      meaningfulnessAssessment\n    };\n  } catch (error) {\n    handleAspirationalCaptureError(error, { aspirationalInput, userContext });\n    return { success: false, error };\n  }\n}\n```\n\n#### 2. Goal Category Prioritization Operation\n```typescript\ninterface GoalCategoryPrioritizationOperation {\n  // Input: Available goal categories and user context\n  input: {\n    availableCategories: GoalCategory[];\n    aspirationalFramework: AspirationalFramework;\n    personalityProfile: MBTIProfile;\n    lifeContext: LifeContext;\n  };\n  \n  // Atomic steps\n  steps: [\n    'analyze_personality_category_affinity',\n    'map_aspirations_to_categories',\n    'assess_life_context_relevance',\n    'generate_personalized_category_recommendations',\n    'calculate_category_synergy_scores'\n  ];\n  \n  // Expected outcome\n  result: {\n    prioritizedCategories: PrioritizedGoalCategory[];\n    personalityRecommendations: CategoryRecommendation[];\n    synergyOpportunities: CategorySynergy[];\n    selectionGuidance: SelectionGuidance;\n  };\n}\n\n// Implementation\nasync function executeGoalCategoryPrioritization(\n  availableCategories: GoalCategory[],\n  aspirationalFramework: AspirationalFramework,\n  personalityProfile: MBTIProfile,\n  lifeContext: LifeContext\n): Promise<GoalCategoryPrioritizationResult> {\n  try {\n    // 1. Analyze personality-category affinity\n    const personalityAffinity = analyzePersonalityCategoryAffinity({\n      categories: availableCategories,\n      personalityType: personalityProfile.type,\n      personalityStrengths: personalityProfile.strengths,\n      personalityDevelopmentAreas: personalityProfile.developmentAreas\n    });\n    \n    // 2. Map aspirations to goal categories\n    const aspirationCategoryMapping = mapAspirationsToCategories({\n      aspirations: aspirationalFramework.parsedAspirations,\n      coreValues: aspirationalFramework.coreValues,\n      categories: availableCategories,\n      motivationPatterns: aspirationalFramework.motivationPatterns\n    });\n    \n    // 3. Assess life context relevance\n    const lifeContextRelevance = assessLifeContextRelevance({\n      categories: availableCategories,\n      lifeContext,\n      personalityProfile,\n      currentLifeStage: lifeContext.currentLifeStage\n    });\n    \n    // 4. Generate personalized category recommendations\n    const categoryRecommendations = generatePersonalizedCategoryRecommendations({\n      personalityAffinity,\n      aspirationMapping: aspirationCategoryMapping,\n      lifeContextRelevance,\n      personalityProfile\n    });\n    \n    // 5. Calculate category synergy scores\n    const synergyAnalysis = calculateCategorySynergyScores({\n      categories: availableCategories,\n      personalityProfile,\n      aspirationalFramework,\n      recommendations: categoryRecommendations\n    });\n    \n    // Generate prioritized category list\n    const prioritizedCategories = prioritizeCategoriesBasedOnAnalysis({\n      personalityAffinity,\n      aspirationMapping: aspirationCategoryMapping,\n      lifeContextRelevance,\n      synergyScores: synergyAnalysis.synergyScores\n    });\n    \n    // Track category prioritization\n    trackEvent('goal_categories_prioritized', {\n      personalityType: personalityProfile.type,\n      topRecommendedCategories: categoryRecommendations.slice(0, 3).map(c => c.categoryId),\n      synergyOpportunitiesCount: synergyAnalysis.synergyOpportunities.length,\n      lifeContextAlignment: lifeContextRelevance.overallAlignmentScore\n    });\n    \n    return {\n      success: true,\n      prioritizedCategories,\n      personalityRecommendations: categoryRecommendations,\n      synergyOpportunities: synergyAnalysis.synergyOpportunities,\n      selectionGuidance: generateCategorySelectionGuidance({\n        prioritizedCategories,\n        personalityProfile,\n        synergyOpportunities: synergyAnalysis.synergyOpportunities\n      })\n    };\n  } catch (error) {\n    handleCategoryPrioritizationError(error, { availableCategories, aspirationalFramework });\n    return { success: false, error };\n  }\n}\n```\n\n#### 3. Specific Goal Formulation Operation\n```typescript\ninterface SpecificGoalFormulationOperation {\n  // Input: Goal formulation context\n  input: {\n    goalCategory: GoalCategory;\n    aspirationalInput: string;\n    personalityProfile: MBTIProfile;\n    timeframePreference: TimeframePreference;\n  };\n  \n  // Atomic steps\n  steps: [\n    'transform_aspiration_to_specific_goal',\n    'apply_smart_goal_principles',\n    'optimize_for_personality_type',\n    'validate_goal_quality_and_achievability',\n    'generate_initial_achievement_strategy'\n  ];\n  \n  // Expected outcome\n  result: {\n    formulatedGoal: SpecificGoal;\n    personalityOptimizations: PersonalityOptimization[];\n    qualityAssessment: GoalQualityAssessment;\n    initialStrategy: InitialAchievementStrategy;\n  };\n}\n\n// Implementation\nasync function executeSpecificGoalFormulation(\n  goalCategory: GoalCategory,\n  aspirationalInput: string,\n  personalityProfile: MBTIProfile,\n  timeframePreference: TimeframePreference\n): Promise<SpecificGoalFormulationResult> {\n  try {\n    // 1. Transform aspiration to specific goal\n    const goalTransformation = await transformAspirationToSpecificGoal({\n      aspiration: aspirationalInput,\n      category: goalCategory,\n      personalityContext: personalityProfile,\n      timeframe: timeframePreference\n    });\n    \n    if (!goalTransformation.isSpecificEnough) {\n      // Generate clarification prompts\n      const clarificationPrompts = generateGoalSpecificationPrompts({\n        currentGoal: goalTransformation.preliminaryGoal,\n        personalityType: personalityProfile.type,\n        category: goalCategory\n      });\n      \n      return {\n        success: false,\n        error: 'insufficient_goal_specificity',\n        clarificationPrompts,\n        preliminaryGoal: goalTransformation.preliminaryGoal\n      };\n    }\n    \n    // 2. Apply SMART goal principles\n    const smartGoalApplication = applySmartGoalPrinciples({\n      preliminaryGoal: goalTransformation.transformedGoal,\n      category: goalCategory,\n      timeframe: timeframePreference,\n      personalityPreferences: personalityProfile.goalPreferences\n    });\n    \n    // 3. Optimize for personality type\n    const personalityOptimizations = optimizeGoalForPersonalityType({\n      smartGoal: smartGoalApplication.optimizedGoal,\n      personalityType: personalityProfile.type,\n      strengths: personalityProfile.strengths,\n      developmentAreas: personalityProfile.developmentAreas\n    });\n    \n    // 4. Validate goal quality and achievability\n    const qualityAssessment = await validateGoalQualityAndAchievability({\n      optimizedGoal: personalityOptimizations.optimizedGoal,\n      personalityProfile,\n      lifeContext: await getUserLifeContext(),\n      category: goalCategory\n    });\n    \n    if (qualityAssessment.overallScore < 0.7) {\n      return {\n        success: false,\n        error: 'goal_quality_insufficient',\n        qualityAssessment,\n        improvementSuggestions: qualityAssessment.improvementSuggestions\n      };\n    }\n    \n    // 5. Generate initial achievement strategy\n    const initialStrategy = await generateInitialAchievementStrategy({\n      finalGoal: personalityOptimizations.optimizedGoal,\n      personalityProfile,\n      category: goalCategory,\n      qualityAssessment\n    });\n    \n    // Create final formulated goal\n    const formulatedGoal: SpecificGoal = {\n      ...personalityOptimizations.optimizedGoal,\n      id: generateGoalId(),\n      categoryId: goalCategory.id,\n      userId: getCurrentUserId(),\n      personalityOptimizations: personalityOptimizations.appliedOptimizations,\n      qualityScore: qualityAssessment.overallScore,\n      achievabilityScore: qualityAssessment.achievabilityScore,\n      createdAt: new Date().toISOString()\n    };\n    \n    // Track goal formulation success\n    trackEvent('specific_goal_formulated', {\n      personalityType: personalityProfile.type,\n      goalCategory: goalCategory.id,\n      qualityScore: qualityAssessment.overallScore,\n      achievabilityScore: qualityAssessment.achievabilityScore,\n      optimizationsApplied: personalityOptimizations.appliedOptimizations.length\n    });\n    \n    return {\n      success: true,\n      formulatedGoal,\n      personalityOptimizations: personalityOptimizations.appliedOptimizations,\n      qualityAssessment,\n      initialStrategy\n    };\n  } catch (error) {\n    handleGoalFormulationError(error, { goalCategory, aspirationalInput });\n    return { success: false, error };\n  }\n}\n```\n\n#### 4. Achievement Strategy Design Operation\n```typescript\ninterface AchievementStrategyDesignOperation {\n  // Input: Goal and context for strategy design\n  input: {\n    specificGoal: SpecificGoal;\n    personalityProfile: MBTIProfile;\n    lifeContext: LifeContext;\n    resourceContext: ResourceContext;\n  };\n  \n  // Atomic steps\n  steps: [\n    'analyze_personality_achievement_preferences',\n    'design_milestone_structure',\n    'create_motivation_sustainability_plan',\n    'anticipate_obstacles_and_mitigation_strategies',\n    'optimize_strategy_for_personality_type'\n  ];\n  \n  // Expected outcome\n  result: {\n    achievementStrategy: AchievementStrategy;\n    milestoneStructure: MilestoneStructure;\n    motivationPlan: MotivationSustainabilityPlan;\n    obstacleAnticipation: ObstacleAnticipationPlan;\n  };\n}\n\n// Implementation\nasync function executeAchievementStrategyDesign(\n  specificGoal: SpecificGoal,\n  personalityProfile: MBTIProfile,\n  lifeContext: LifeContext,\n  resourceContext: ResourceContext\n): Promise<AchievementStrategyDesignResult> {\n  try {\n    // 1. Analyze personality achievement preferences\n    const achievementPreferences = analyzePersonalityAchievementPreferences({\n      personalityType: personalityProfile.type,\n      strengths: personalityProfile.strengths,\n      motivationPatterns: personalityProfile.motivationPatterns,\n      goalCategory: specificGoal.category\n    });\n    \n    // 2. Design milestone structure\n    const milestoneStructure = designPersonalityOptimizedMilestoneStructure({\n      goal: specificGoal,\n      achievementPreferences,\n      timeframe: specificGoal.timeframe,\n      personalityType: personalityProfile.type\n    });\n    \n    // 3. Create motivation sustainability plan\n    const motivationPlan = createMotivationSustainabilityPlan({\n      goal: specificGoal,\n      personalityProfile,\n      milestones: milestoneStructure.milestones,\n      lifeContext\n    });\n    \n    // 4. Anticipate obstacles and mitigation strategies\n    const obstacleAnticipation = anticipateObstaclesAndMitigationStrategies({\n      goal: specificGoal,\n      personalityProfile,\n      lifeContext,\n      resourceContext,\n      historicalObstaclePatterns: await getUserObstaclePatterns()\n    });\n    \n    // 5. Optimize strategy for personality type\n    const optimizedStrategy = optimizeStrategyForPersonalityType({\n      preliminaryStrategy: {\n        milestones: milestoneStructure,\n        motivationPlan,\n        obstacleAnticipation\n      },\n      personalityProfile,\n      achievementPreferences\n    });\n    \n    // Create final achievement strategy\n    const achievementStrategy: AchievementStrategy = {\n      id: generateStrategyId(),\n      goalId: specificGoal.id,\n      userId: getCurrentUserId(),\n      personalityOptimizations: optimizedStrategy.appliedOptimizations,\n      milestoneStructure: optimizedStrategy.optimizedMilestones,\n      motivationApproach: optimizedStrategy.optimizedMotivationPlan,\n      obstacleManagement: optimizedStrategy.optimizedObstacleAnticipation,\n      resourceRequirements: calculateResourceRequirements(optimizedStrategy),\n      effectivenessScore: calculateStrategyEffectivenessScore(optimizedStrategy, personalityProfile),\n      createdAt: new Date().toISOString()\n    };\n    \n    // Track strategy design success\n    trackEvent('achievement_strategy_designed', {\n      personalityType: personalityProfile.type,\n      goalCategory: specificGoal.category,\n      milestoneCount: optimizedStrategy.optimizedMilestones.milestones.length,\n      motivationTechniques: optimizedStrategy.optimizedMotivationPlan.techniques.length,\n      anticipatedObstacles: optimizedStrategy.optimizedObstacleAnticipation.obstacles.length,\n      effectivenessScore: achievementStrategy.effectivenessScore\n    });\n    \n    return {\n      success: true,\n      achievementStrategy,\n      milestoneStructure: optimizedStrategy.optimizedMilestones,\n      motivationPlan: optimizedStrategy.optimizedMotivationPlan,\n      obstacleAnticipation: optimizedStrategy.optimizedObstacleAnticipation\n    };\n  } catch (error) {\n    handleStrategyDesignError(error, { specificGoal, personalityProfile });\n    return { success: false, error };\n  }\n}\n```\n\n### Support Operations\n\n#### 5. Goal Quality Assessment Operation\n```typescript\ninterface GoalQualityAssessmentOperation {\n  // Input: Goal for quality assessment\n  input: {\n    goal: SpecificGoal;\n    personalityProfile: MBTIProfile;\n    lifeContext: LifeContext;\n    assessmentCriteria: QualityAssessmentCriteria;\n  };\n  \n  // Atomic steps\n  steps: [\n    'assess_goal_specificity_and_clarity',\n    'evaluate_personality_alignment',\n    'analyze_achievability_and_realism',\n    'measure_meaningfulness_and_value_alignment',\n    'calculate_composite_quality_score'\n  ];\n  \n  // Expected outcome\n  result: {\n    qualityAssessment: GoalQualityAssessment;\n    improvementRecommendations: QualityImprovementRecommendation[];\n    riskFactors: QualityRiskFactor[];\n    confidenceScore: number;\n  };\n}\n\n// Implementation\nasync function executeGoalQualityAssessment(\n  goal: SpecificGoal,\n  personalityProfile: MBTIProfile,\n  lifeContext: LifeContext,\n  assessmentCriteria: QualityAssessmentCriteria\n): Promise<GoalQualityAssessmentResult> {\n  try {\n    // 1. Assess goal specificity and clarity\n    const specificityAssessment = assessGoalSpecificityAndClarity({\n      goal,\n      criteria: assessmentCriteria.specificityRequirements,\n      personalityContext: personalityProfile\n    });\n    \n    // 2. Evaluate personality alignment\n    const personalityAlignment = evaluatePersonalityAlignment({\n      goal,\n      personalityProfile,\n      strengths: personalityProfile.strengths,\n      developmentAreas: personalityProfile.developmentAreas,\n      motivationPatterns: personalityProfile.motivationPatterns\n    });\n    \n    // 3. Analyze achievability and realism\n    const achievabilityAnalysis = analyzeAchievabilityAndRealism({\n      goal,\n      lifeContext,\n      resourceAvailability: await assessUserResourceAvailability(),\n      personalityProfile,\n      historicalAchievementPatterns: await getUserAchievementPatterns()\n    });\n    \n    // 4. Measure meaningfulness and value alignment\n    const meaningfulnessAssessment = measureMeaningfulnessAndValueAlignment({\n      goal,\n      userValues: await getUserCoreValues(),\n      personalityValues: personalityProfile.coreValues,\n      lifeContext,\n      aspirationalFramework: await getUserAspirationalFramework()\n    });\n    \n    // 5. Calculate composite quality score\n    const compositeScore = calculateCompositeQualityScore({\n      specificityScore: specificityAssessment.score,\n      personalityAlignmentScore: personalityAlignment.score,\n      achievabilityScore: achievabilityAnalysis.score,\n      meaningfulnessScore: meaningfulnessAssessment.score,\n      weights: assessmentCriteria.qualityWeights\n    });\n    \n    // Generate improvement recommendations\n    const improvementRecommendations = generateQualityImprovementRecommendations({\n      specificityGaps: specificityAssessment.gaps,\n      personalityMisalignments: personalityAlignment.misalignments,\n      achievabilityRisks: achievabilityAnalysis.risks,\n      meaningfulnessDeficits: meaningfulnessAssessment.deficits,\n      personalityProfile\n    });\n    \n    // Identify risk factors\n    const riskFactors = identifyQualityRiskFactors({\n      assessmentResults: {\n        specificity: specificityAssessment,\n        personalityAlignment,\n        achievability: achievabilityAnalysis,\n        meaningfulness: meaningfulnessAssessment\n      },\n      compositeScore,\n      personalityProfile\n    });\n    \n    // Create quality assessment\n    const qualityAssessment: GoalQualityAssessment = {\n      goalId: goal.id,\n      overallScore: compositeScore.overallScore,\n      dimensionScores: {\n        specificity: specificityAssessment.score,\n        personalityAlignment: personalityAlignment.score,\n        achievability: achievabilityAnalysis.score,\n        meaningfulness: meaningfulnessAssessment.score\n      },\n      assessmentDetails: {\n        specificityAnalysis: specificityAssessment,\n        personalityAlignmentAnalysis: personalityAlignment,\n        achievabilityAnalysis,\n        meaningfulnessAnalysis: meaningfulnessAssessment\n      },\n      riskLevel: calculateRiskLevel(riskFactors),\n      confidenceLevel: compositeScore.confidenceScore,\n      assessmentDate: new Date().toISOString()\n    };\n    \n    // Track quality assessment\n    trackEvent('goal_quality_assessed', {\n      personalityType: personalityProfile.type,\n      goalCategory: goal.category,\n      overallScore: compositeScore.overallScore,\n      riskLevel: qualityAssessment.riskLevel,\n      improvementRecommendationsCount: improvementRecommendations.length\n    });\n    \n    return {\n      success: true,\n      qualityAssessment,\n      improvementRecommendations,\n      riskFactors,\n      confidenceScore: compositeScore.confidenceScore\n    };\n  } catch (error) {\n    handleQualityAssessmentError(error, { goal, personalityProfile });\n    return { success: false, error };\n  }\n}\n```\n\n#### 6. Goal Progress Tracking Operation\n```typescript\ninterface GoalProgressTrackingOperation {\n  // Input: Progress tracking context\n  input: {\n    goalId: string;\n    progressUpdate: ProgressUpdate;\n    personalityProfile: MBTIProfile;\n    trackingMethod: TrackingMethod;\n  };\n  \n  // Atomic steps\n  steps: [\n    'validate_and_normalize_progress_data',\n    'analyze_progress_patterns_and_trends',\n    'assess_strategy_effectiveness',\n    'identify_optimization_opportunities',\n    'generate_personalized_progress_insights'\n  ];\n  \n  // Expected outcome\n  result: {\n    progressAnalysis: ProgressAnalysis;\n    strategyEffectivenessAssessment: StrategyEffectivenessAssessment;\n    optimizationRecommendations: OptimizationRecommendation[];\n    motivationInsights: MotivationInsight[];\n  };\n}\n\n// Implementation\nasync function executeGoalProgressTracking(\n  goalId: string,\n  progressUpdate: ProgressUpdate,\n  personalityProfile: MBTIProfile,\n  trackingMethod: TrackingMethod\n): Promise<GoalProgressTrackingResult> {\n  try {\n    // 1. Validate and normalize progress data\n    const normalizedProgress = validateAndNormalizeProgressData({\n      progressUpdate,\n      trackingMethod,\n      goal: await getGoalById(goalId),\n      previousProgress: await getGoalProgressHistory(goalId)\n    });\n    \n    if (!normalizedProgress.isValid) {\n      return {\n        success: false,\n        error: 'invalid_progress_data',\n        validationErrors: normalizedProgress.errors\n      };\n    }\n    \n    // 2. Analyze progress patterns and trends\n    const progressAnalysis = analyzeProgressPatternsAndTrends({\n      normalizedProgress: normalizedProgress.data,\n      progressHistory: await getGoalProgressHistory(goalId),\n      personalityProfile,\n      goalStrategy: await getGoalStrategy(goalId)\n    });\n    \n    // 3. Assess strategy effectiveness\n    const strategyEffectiveness = assessStrategyEffectiveness({\n      progressAnalysis,\n      currentStrategy: await getGoalStrategy(goalId),\n      personalityProfile,\n      progressUpdate: normalizedProgress.data\n    });\n    \n    // 4. Identify optimization opportunities\n    const optimizationOpportunities = identifyOptimizationOpportunities({\n      progressAnalysis,\n      strategyEffectiveness,\n      personalityProfile,\n      goalContext: await getGoalContext(goalId)\n    });\n    \n    // 5. Generate personalized progress insights\n    const progressInsights = generatePersonalizedProgressInsights({\n      progressAnalysis,\n      personalityProfile,\n      optimizationOpportunities,\n      motivationPatterns: await getUserMotivationPatterns()\n    });\n    \n    // Store progress update\n    await storeProgressUpdate({\n      goalId,\n      progressData: normalizedProgress.data,\n      analysisResults: {\n        progressAnalysis,\n        strategyEffectiveness,\n        optimizationOpportunities\n      },\n      timestamp: new Date().toISOString()\n    });\n    \n    // Track progress tracking event\n    trackEvent('goal_progress_tracked', {\n      personalityType: personalityProfile.type,\n      goalId,\n      progressTrend: progressAnalysis.trend,\n      strategyEffectivenessScore: strategyEffectiveness.score,\n      optimizationOpportunitiesCount: optimizationOpportunities.length\n    });\n    \n    return {\n      success: true,\n      progressAnalysis,\n      strategyEffectivenessAssessment: strategyEffectiveness,\n      optimizationRecommendations: optimizationOpportunities,\n      motivationInsights: progressInsights.motivationInsights\n    };\n  } catch (error) {\n    handleProgressTrackingError(error, { goalId, progressUpdate });\n    return { success: false, error };\n  }\n}\n```\n\n## Composite Operations\n\n### Multi-Step Workflows\n\n#### 1. Complete Goal Setting Workflow\n```typescript\ninterface CompleteGoalSettingWorkflow {\n  // Orchestrates entire goal setting process\n  operations: [\n    AspirationalGoalCaptureOperation,\n    GoalCategoryPrioritizationOperation,\n    SpecificGoalFormulationOperation[],\n    AchievementStrategyDesignOperation[],\n    GoalQualityAssessmentOperation[]\n  ];\n  \n  // Transaction boundary\n  transactionScope: 'complete_goal_setting_session';\n  \n  // Rollback procedures\n  rollbackActions: [\n    'restore_previous_goal_state',\n    'clear_incomplete_goal_formulations',\n    'reset_category_prioritizations'\n  ];\n}\n\n// Implementation\nasync function executeCompleteGoalSettingWorkflow(\n  goalSettingSession: GoalSettingSession\n): Promise<GoalSettingWorkflowResult> {\n  const transaction = beginGoalSettingTransaction();\n  \n  try {\n    // 1. Capture aspirational foundation\n    const aspirationalCapture = await executeAspirationalGoalCapture(\n      goalSettingSession.aspirationalInput,\n      goalSettingSession.userContext,\n      goalSettingSession.personalityProfile\n    );\n    \n    if (!aspirationalCapture.success) {\n      return {\n        success: false,\n        error: 'aspirational_capture_failed',\n        clarificationNeeded: aspirationalCapture.clarificationQuestions\n      };\n    }\n    \n    // 2. Prioritize goal categories\n    const categoryPrioritization = await executeGoalCategoryPrioritization(\n      goalSettingSession.availableCategories,\n      aspirationalCapture.structuredAspirations,\n      goalSettingSession.personalityProfile,\n      goalSettingSession.lifeContext\n    );\n    \n    // 3. Formulate specific goals for selected categories\n    const goalFormulations = await Promise.allSettled(\n      goalSettingSession.selectedCategories.map(async (category) => {\n        const goalInput = goalSettingSession.categoryGoalInputs[category.id];\n        return await executeSpecificGoalFormulation(\n          category,\n          goalInput,\n          goalSettingSession.personalityProfile,\n          goalSettingSession.timeframePreferences[category.id]\n        );\n      })\n    );\n    \n    // 4. Design achievement strategies for formulated goals\n    const successfulGoals = goalFormulations\n      .filter(result => result.status === 'fulfilled' && result.value.success)\n      .map(result => result.value.formulatedGoal);\n    \n    const strategyDesigns = await Promise.allSettled(\n      successfulGoals.map(async (goal) => {\n        return await executeAchievementStrategyDesign(\n          goal,\n          goalSettingSession.personalityProfile,\n          goalSettingSession.lifeContext,\n          goalSettingSession.resourceContext\n        );\n      })\n    );\n    \n    // 5. Assess quality of complete goal set\n    const qualityAssessments = await Promise.allSettled(\n      successfulGoals.map(async (goal) => {\n        return await executeGoalQualityAssessment(\n          goal,\n          goalSettingSession.personalityProfile,\n          goalSettingSession.lifeContext,\n          goalSettingSession.qualityAssessmentCriteria\n        );\n      })\n    );\n    \n    // Commit transaction\n    const workflowResults = {\n      aspirationalFoundation: aspirationalCapture.structuredAspirations,\n      prioritizedCategories: categoryPrioritization.prioritizedCategories,\n      formulatedGoals: successfulGoals,\n      achievementStrategies: strategyDesigns\n        .filter(result => result.status === 'fulfilled' && result.value.success)\n        .map(result => result.value.achievementStrategy),\n      qualityAssessments: qualityAssessments\n        .filter(result => result.status === 'fulfilled' && result.value.success)\n        .map(result => result.value.qualityAssessment)\n    };\n    \n    await transaction.commit(workflowResults);\n    \n    return {\n      success: true,\n      goalSettingComplete: true,\n      nextStep: 7,\n      workflowResults\n    };\n  } catch (error) {\n    // Rollback on error\n    await transaction.rollback();\n    return {\n      success: false,\n      error,\n      partialResults: transaction.getPartialResults()\n    };\n  }\n}\n```\n\n#### 2. Adaptive Goal Optimization Workflow\n```typescript\ninterface AdaptiveGoalOptimizationWorkflow {\n  // Continuously optimizes goals based on progress and insights\n  operations: [\n    'monitor_goal_progress_across_all_goals',\n    'analyze_goal_synergies_and_conflicts',\n    'optimize_strategies_based_on_effectiveness_data',\n    'evolve_goals_based_on_personality_insights',\n    'rebalance_goal_portfolio_for_optimal_outcomes'\n  ];\n}\n\n// Implementation\nasync function executeAdaptiveGoalOptimizationWorkflow(\n  userId: string\n): Promise<AdaptiveOptimizationWorkflowResult> {\n  // 1. Monitor goal progress across all goals\n  const allGoalsProgress = await monitorAllGoalsProgress(userId, {\n    includeProgressTrends: true,\n    analyzePatterns: true,\n    assessMotivationLevels: true\n  });\n  \n  // 2. Analyze goal synergies and conflicts\n  const synergyAnalysis = analyzeGoalSynergiesAndConflicts({\n    userGoals: await getUserGoals(userId),\n    progressData: allGoalsProgress,\n    personalityProfile: await getUserPersonalityProfile(userId)\n  });\n  \n  // 3. Optimize strategies based on effectiveness data\n  const strategyOptimizations = await optimizeStrategiesBasedOnEffectiveness({\n    userId,\n    goalProgressData: allGoalsProgress,\n    personalityProfile: await getUserPersonalityProfile(userId),\n    effectivenessPatterns: synergyAnalysis.effectivenessPatterns\n  });\n  \n  // 4. Evolve goals based on personality insights\n  const goalEvolutions = await evolveGoalsBasedOnPersonalityInsights({\n    userId,\n    currentGoals: await getUserGoals(userId),\n    personalityGrowth: await getPersonalityGrowthInsights(userId),\n    lifeContextChanges: await getLifeContextChanges(userId)\n  });\n  \n  // 5. Rebalance goal portfolio for optimal outcomes\n  const portfolioRebalancing = await rebalanceGoalPortfolioForOptimalOutcomes({\n    userId,\n    optimizedStrategies: strategyOptimizations,\n    evolvedGoals: goalEvolutions,\n    synergyOpportunities: synergyAnalysis.synergyOpportunities\n  });\n  \n  return {\n    success: true,\n    progressAnalyzed: true,\n    strategiesOptimized: strategyOptimizations.length,\n    goalsEvolved: goalEvolutions.length,\n    portfolioRebalanced: portfolioRebalancing.rebalanced,\n    optimizationResults: {\n      progressAnalysis: allGoalsProgress,\n      synergyAnalysis,\n      strategyOptimizations,\n      goalEvolutions,\n      portfolioRebalancing\n    }\n  };\n}\n```\n\n## Performance Operations\n\n### Goal Processing Optimization\n```typescript\n// Optimize goal processing performance\nasync function optimizeGoalProcessing(): Promise<GoalProcessingOptimizationResult> {\n  const optimizationTasks = {\n    // Critical optimizations\n    critical: [\n      optimizeGoalFormulationSpeed(),\n      optimizePersonalityAlignmentCalculation(),\n      optimizeQualityAssessmentPerformance()\n    ],\n    \n    // Important optimizations\n    important: [\n      optimizeStrategyGenerationEfficiency(),\n      optimizeProgressAnalysisSpeed(),\n      optimizeRecommendationEnginePerformance()\n    ],\n    \n    // Background optimizations\n    background: [\n      optimizeGoalSynergyCalculations(),\n      optimizeMLModelInference(),\n      optimizeDataStorageAndRetrieval()\n    ]\n  };\n  \n  // Execute optimizations in priority order\n  const criticalResults = await Promise.all(optimizationTasks.critical);\n  const importantResults = await Promise.allSettled(optimizationTasks.important);\n  \n  // Background optimizations run asynchronously\n  Promise.allSettled(optimizationTasks.background).then(backgroundResults => {\n    processBackgroundGoalOptimizations(backgroundResults);\n  });\n  \n  return {\n    criticalOptimizations: criticalResults,\n    importantOptimizations: importantResults.filter(r => r.status === 'fulfilled'),\n    optimizationStrategy: 'goal_processing_performance_first'\n  };\n}\n```\n\n### Error Recovery Operations\n```typescript\n// Comprehensive error recovery for goal operations\nasync function executeGoalErrorRecovery(\n  error: GoalError,\n  context: GoalErrorContext\n): Promise<GoalRecoveryResult> {\n  const recoveryStrategies = {\n    'goal_formulation_failed': async () => {\n      // Provide alternative formulation approaches\n      return await provideAlternativeFormulationApproaches(context.goalInput, context.personalityProfile);\n    },\n    \n    'strategy_generation_failed': async () => {\n      // Fall back to template-based strategies\n      return await useTemplateBasedStrategies(context.goal, context.personalityProfile);\n    },\n    \n    'quality_assessment_failed': async () => {\n      // Use simplified quality assessment\n      return await useSimplifiedQualityAssessment(context.goal);\n    },\n    \n    'progress_tracking_failed': async () => {\n      // Enable manual progress tracking mode\n      return await enableManualProgressTrackingMode(context.goalId);\n    }\n  };\n  \n  const strategy = recoveryStrategies[error.type];\n  if (strategy) {\n    return await strategy();\n  }\n  \n  // Generic recovery\n  return await executeGenericGoalRecovery(error, context);\n}\n```\n\nThese atomic operations provide the complete foundation for implementing Step 6 (Goals/Aspirations) with full BMAD compliance, ensuring systematic goal collection, personality-optimized formulation, intelligent strategy design, and continuous optimization while maintaining deep integration with the personality insights system.