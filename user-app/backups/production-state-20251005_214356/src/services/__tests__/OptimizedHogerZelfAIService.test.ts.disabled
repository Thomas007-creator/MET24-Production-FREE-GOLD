import { OptimizedHogerZelfAIService } from '../OptimizedHogerZelfAIService';

// Mock logger
jest.mock('../../utils/logger', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn()
  }
}));

// Mock AI client
jest.mock('../../lib/api/aiClient', () => ({
  streamAiResponse: jest.fn()
}));

describe('OptimizedHogerZelfAIService', () => {
  let service: OptimizedHogerZelfAIService;

  beforeEach(() => {
    service = new OptimizedHogerZelfAIService();
    jest.clearAllMocks();
  });

  describe('generateOptimizedPrompt', () => {
    test('generates optimized prompt', () => {
      const prompt = service.generateOptimizedPrompt({}, 'INTJ', 'Test message');
      expect(prompt).toContain('INTJ archetype');
      expect(prompt).toContain('max 200 tokens');
    });

    test('includes user context in prompt', () => {
      const userContext = { needsWisdom: true, needsCreativity: false };
      const prompt = service.generateOptimizedPrompt(userContext, 'INFJ', 'Help me grow');
      
      expect(prompt).toContain('INFJ archetype');
      expect(prompt).toContain('"needsWisdom":true');
      expect(prompt).toContain('Help me grow');
      expect(prompt).toContain('actionable inzichten');
    });

    test('includes Beauty, Wisdom, Goodness principles', () => {
      const prompt = service.generateOptimizedPrompt({}, 'ENFP', 'Test');
      
      expect(prompt).toContain('Beauty, Wisdom, Goodness');
      expect(prompt).toContain('ENFP archetype');
    });

    test('handles empty user context', () => {
      const prompt = service.generateOptimizedPrompt(null, 'ISFJ', 'Empty context test');
      
      expect(prompt).toContain('ISFJ archetype');
      expect(prompt).toContain('Empty context test');
      expect(prompt).toContain('max 200 tokens');
    });
  });

  describe('orchestrateResponse', () => {
    test('calls AI provider with optimized prompt', async () => {
      const mockStream = {
        [Symbol.asyncIterator]: async function* () {
          yield 'Test response';
        }
      };

      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockResolvedValue(mockStream);

      const userContext = { needsWisdom: true };
      const mbtiType = 'INTJ';
      const userMessage = 'Test message';

      const result = await service.orchestrateResponse(userContext, mbtiType, userMessage);

      expect(result).toBe('Test response');
      expect(streamAiResponse).toHaveBeenCalledWith({
        sessionId: expect.stringMatching(/^hoger-zelf-\d+$/),
        userId: 'system',
        mbtiType: 'INTJ',
        promptContext: expect.stringContaining('INTJ archetype')
      });
    });

    test('handles streaming response successfully', async () => {
      const mockStream = async function* () {
        yield 'Chunk 1';
        yield 'Chunk 2';
        yield 'Chunk 3';
      };
      
      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockResolvedValue(mockStream());

      const userContext = { needsCreativity: true };
      const mbtiType = 'ENFP';
      const userMessage = 'Help me be more creative';

      const result = await service.orchestrateResponse(userContext, mbtiType, userMessage);

      expect(result).toBe('Chunk 1Chunk 2Chunk 3');
      expect(streamAiResponse).toHaveBeenCalledWith({
        sessionId: expect.stringMatching(/^hoger-zelf-\d+$/),
        userId: 'system',
        mbtiType: 'ENFP',
        promptContext: expect.stringContaining('ENFP archetype')
      });
    });

    test('handles AI provider failure gracefully', async () => {
      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockRejectedValue(new Error('AI service unavailable'));

      const result = await service.orchestrateResponse({}, 'INFJ', 'Test message');

      expect(result).toBe('Ik ben je Hogere Zelf AI, maar er is een technische storing. Probeer het opnieuw.');
    });
  });

  describe('getMBTIPrinciples', () => {
    test('returns correct principles for known MBTI type', () => {
      const principles = (service as any).getMBTIPrinciples('INTJ');
      
      expect(principles).toHaveProperty('archetype');
      expect(principles).toHaveProperty('theOneManifestation');
      expect(principles).toHaveProperty('higherSelf');
      expect(principles).toHaveProperty('optimalRealization');
    });

    test('returns default principles for unknown MBTI type', () => {
      const principles = (service as any).getMBTIPrinciples('UNKNOWN');
      
      expect(principles.archetype).toBe('Universele Manifestatie');
      expect(principles.theOneManifestation).toBe('The One via universele principes');
    });
  });

  describe('getArchetypeForMBTI', () => {
    test('returns archetype for known MBTI type', () => {
      const archetype = (service as any).getArchetypeForMBTI('INFJ');
      
      expect(archetype).toHaveProperty('archetype');
      expect(archetype).toHaveProperty('theOneManifestation');
      expect(archetype).toHaveProperty('higherSelf');
    });

    test('returns undefined for unknown MBTI type', () => {
      const archetype = (service as any).getArchetypeForMBTI('UNKNOWN');
      
      expect(archetype).toBeUndefined();
    });
  });

  describe('inheritance from HogerZelfAIService', () => {
    test('inherits selectTheOneEmanations method', () => {
      const context = { needsCreativity: true };
      const emanations = service.selectTheOneEmanations(context, 'INFJ');
      
      expect(emanations).toContain('beauty');
    });

    test('inherits buildHogerZelfContext method', () => {
      const context = service.buildHogerZelfContext({}, 'ENFP');
      
      expect(context).toHaveProperty('archetype');
      expect(context).toHaveProperty('mbtiType');
      expect(context.mbtiType).toBe('ENFP');
    });
  });
});

// Mock logger
jest.mock('../../utils/logger', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn()
  }
}));

// Mock AI client
jest.mock('../../lib/api/aiClient', () => ({
  streamAiResponse: jest.fn()
}));

describe('OptimizedHogerZelfAIService', () => {
  let service: OptimizedHogerZelfAIService;

  beforeEach(() => {
    service = new OptimizedHogerZelfAIService();
    jest.clearAllMocks();
  });

  describe('generateOptimizedPrompt', () => {
    test('generates optimized prompt', () => {
      const prompt = service.generateOptimizedPrompt({}, 'INTJ', 'Test message');
      expect(prompt).toContain('INTJ archetype');
      expect(prompt).toContain('max 200 tokens');
    });

    test('includes user context in prompt', () => {
      const userContext = { needsWisdom: true, needsCreativity: false };
      const prompt = service.generateOptimizedPrompt(userContext, 'INFJ', 'Help me grow');
      
      expect(prompt).toContain('INFJ archetype');
      expect(prompt).toContain('"needsWisdom":true');
      expect(prompt).toContain('Help me grow');
      expect(prompt).toContain('actionable inzichten');
    });

    test('includes Beauty, Wisdom, Goodness principles', () => {
      const prompt = service.generateOptimizedPrompt({}, 'ENFP', 'Test');
      
      expect(prompt).toContain('Beauty, Wisdom, Goodness');
      expect(prompt).toContain('ENFP archetype');
    });

    test('handles empty user context', () => {
      const prompt = service.generateOptimizedPrompt(null, 'ISFJ', 'Empty context test');
      
      expect(prompt).toContain('ISFJ archetype');
      expect(prompt).toContain('Empty context test');
      expect(prompt).toContain('max 200 tokens');
    });
  });

  describe('orchestrateResponse', () => {
    test('calls AI provider with optimized prompt', async () => {
      const mockStream = {
        [Symbol.asyncIterator]: async function* () {
          yield 'Test response';
        }
      };

      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockResolvedValue(mockStream);

      const userContext = { needsWisdom: true };
      const mbtiType = 'INTJ';
      const userMessage = 'Test message';

      const result = await service.orchestrateResponse(userContext, mbtiType, userMessage);

      expect(result).toBe('Test response');
      expect(streamAiResponse).toHaveBeenCalledWith({
        sessionId: expect.stringMatching(/^hoger-zelf-\d+$/),
        userId: 'system',
        mbtiType: 'INTJ',
        promptContext: expect.stringContaining('INTJ archetype')
      });
    });

    test('handles streaming response successfully', async () => {
      const mockStream = async function* () {
        yield 'Chunk 1';
        yield 'Chunk 2';
        yield 'Chunk 3';
      };
      
      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockResolvedValue(mockStream());

      const userContext = { needsCreativity: true };
      const mbtiType = 'ENFP';
      const userMessage = 'Help me be more creative';

      const result = await service.orchestrateResponse(userContext, mbtiType, userMessage);

      expect(result).toBe('Chunk 1Chunk 2Chunk 3');
      expect(streamAiResponse).toHaveBeenCalledWith({
        sessionId: expect.stringMatching(/^hoger-zelf-\d+$/),
        userId: 'system',
        mbtiType: 'ENFP',
        promptContext: expect.stringContaining('ENFP archetype')
      });
    });

    test('handles AI provider failure gracefully', async () => {
      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockRejectedValue(new Error('AI service unavailable'));

      const result = await service.orchestrateResponse({}, 'INFJ', 'Test message');

      expect(result).toBe('Ik ben je Hogere Zelf AI, maar er is een technische storing. Probeer het opnieuw.');
    });
  });

  describe('getMBTIPrinciples', () => {
    test('returns correct principles for known MBTI type', () => {
      const principles = (service as any).getMBTIPrinciples('INTJ');
      
      expect(principles).toHaveProperty('archetype');
      expect(principles).toHaveProperty('theOneManifestation');
      expect(principles).toHaveProperty('higherSelf');
      expect(principles).toHaveProperty('optimalRealization');
    });

    test('returns default principles for unknown MBTI type', () => {
      const principles = (service as any).getMBTIPrinciples('UNKNOWN');
      
      expect(principles.archetype).toBe('Universele Manifestatie');
      expect(principles.theOneManifestation).toBe('The One via universele principes');
    });
  });

  describe('getArchetypeForMBTI', () => {
    test('returns archetype for known MBTI type', () => {
      const archetype = (service as any).getArchetypeForMBTI('INFJ');
      
      expect(archetype).toHaveProperty('archetype');
      expect(archetype).toHaveProperty('theOneManifestation');
      expect(archetype).toHaveProperty('higherSelf');
    });

    test('returns undefined for unknown MBTI type', () => {
      const archetype = (service as any).getArchetypeForMBTI('UNKNOWN');
      
      expect(archetype).toBeUndefined();
    });
  });

  describe('inheritance from HogerZelfAIService', () => {
    test('inherits selectTheOneEmanations method', () => {
      const context = { needsCreativity: true };
      const emanations = service.selectTheOneEmanations(context, 'INFJ');
      
      expect(emanations).toContain('beauty');
    });

    test('inherits buildHogerZelfContext method', () => {
      const context = service.buildHogerZelfContext({}, 'ENFP');
      
      expect(context).toHaveProperty('archetype');
      expect(context).toHaveProperty('mbtiType');
      expect(context.mbtiType).toBe('ENFP');
    });
  });
});

// Mock logger
jest.mock('../../utils/logger', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn()
  }
}));

// Mock AI client
jest.mock('../../lib/api/aiClient', () => ({
  streamAiResponse: jest.fn()
}));

describe('OptimizedHogerZelfAIService', () => {
  let service: OptimizedHogerZelfAIService;

  beforeEach(() => {
    service = new OptimizedHogerZelfAIService();
    jest.clearAllMocks();
  });

  describe('generateOptimizedPrompt', () => {
    test('generates optimized prompt', () => {
      const prompt = service.generateOptimizedPrompt({}, 'INTJ', 'Test message');
      expect(prompt).toContain('INTJ archetype');
      expect(prompt).toContain('max 200 tokens');
    });

    test('includes user context in prompt', () => {
      const userContext = { needsWisdom: true, needsCreativity: false };
      const prompt = service.generateOptimizedPrompt(userContext, 'INFJ', 'Help me grow');
      
      expect(prompt).toContain('INFJ archetype');
      expect(prompt).toContain('"needsWisdom":true');
      expect(prompt).toContain('Help me grow');
      expect(prompt).toContain('actionable inzichten');
    });

    test('includes Beauty, Wisdom, Goodness principles', () => {
      const prompt = service.generateOptimizedPrompt({}, 'ENFP', 'Test');
      
      expect(prompt).toContain('Beauty, Wisdom, Goodness');
      expect(prompt).toContain('ENFP archetype');
    });

    test('handles empty user context', () => {
      const prompt = service.generateOptimizedPrompt(null, 'ISFJ', 'Empty context test');
      
      expect(prompt).toContain('ISFJ archetype');
      expect(prompt).toContain('Empty context test');
      expect(prompt).toContain('max 200 tokens');
    });
  });

  describe('orchestrateResponse', () => {
    test('calls AI provider with optimized prompt', async () => {
      const mockStream = {
        [Symbol.asyncIterator]: async function* () {
          yield 'Test response';
        }
      };

      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockResolvedValue(mockStream);

      const userContext = { needsWisdom: true };
      const mbtiType = 'INTJ';
      const userMessage = 'Test message';

      const result = await service.orchestrateResponse(userContext, mbtiType, userMessage);

      expect(result).toBe('Test response');
      expect(streamAiResponse).toHaveBeenCalledWith({
        sessionId: expect.stringMatching(/^hoger-zelf-\d+$/),
        userId: 'system',
        mbtiType: 'INTJ',
        promptContext: expect.stringContaining('INTJ archetype')
      });
    });

    test('handles streaming response successfully', async () => {
      const mockStream = async function* () {
        yield 'Chunk 1';
        yield 'Chunk 2';
        yield 'Chunk 3';
      };
      
      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockResolvedValue(mockStream());

      const userContext = { needsCreativity: true };
      const mbtiType = 'ENFP';
      const userMessage = 'Help me be more creative';

      const result = await service.orchestrateResponse(userContext, mbtiType, userMessage);

      expect(result).toBe('Chunk 1Chunk 2Chunk 3');
      expect(streamAiResponse).toHaveBeenCalledWith({
        sessionId: expect.stringMatching(/^hoger-zelf-\d+$/),
        userId: 'system',
        mbtiType: 'ENFP',
        promptContext: expect.stringContaining('ENFP archetype')
      });
    });

    test('handles AI provider failure gracefully', async () => {
      const { streamAiResponse } = require('../../lib/api/aiClient');
      streamAiResponse.mockRejectedValue(new Error('AI service unavailable'));

      const result = await service.orchestrateResponse({}, 'INFJ', 'Test message');

      expect(result).toBe('Ik ben je Hogere Zelf AI, maar er is een technische storing. Probeer het opnieuw.');
    });
  });

  describe('getMBTIPrinciples', () => {
    test('returns correct principles for known MBTI type', () => {
      const principles = (service as any).getMBTIPrinciples('INTJ');
      
      expect(principles).toHaveProperty('archetype');
      expect(principles).toHaveProperty('theOneManifestation');
      expect(principles).toHaveProperty('higherSelf');
      expect(principles).toHaveProperty('optimalRealization');
    });

    test('returns default principles for unknown MBTI type', () => {
      const principles = (service as any).getMBTIPrinciples('UNKNOWN');
      
      expect(principles.archetype).toBe('Universele Manifestatie');
      expect(principles.theOneManifestation).toBe('The One via universele principes');
    });
  });

  describe('getArchetypeForMBTI', () => {
    test('returns archetype for known MBTI type', () => {
      const archetype = (service as any).getArchetypeForMBTI('INFJ');
      
      expect(archetype).toHaveProperty('archetype');
      expect(archetype).toHaveProperty('theOneManifestation');
      expect(archetype).toHaveProperty('higherSelf');
    });

    test('returns undefined for unknown MBTI type', () => {
      const archetype = (service as any).getArchetypeForMBTI('UNKNOWN');
      
      expect(archetype).toBeUndefined();
    });
  });

  describe('inheritance from HogerZelfAIService', () => {
    test('inherits selectTheOneEmanations method', () => {
      const context = { needsCreativity: true };
      const emanations = service.selectTheOneEmanations(context, 'INFJ');
      
      expect(emanations).toContain('beauty');
    });

    test('inherits buildHogerZelfContext method', () => {
      const context = service.buildHogerZelfContext({}, 'ENFP');
      
      expect(context).toHaveProperty('archetype');
      expect(context).toHaveProperty('mbtiType');
      expect(context.mbtiType).toBe('ENFP');
    });
  });
});




